        .TITLE  TERM52 - VT52 TERMINAL .IDENT  /V04.00/

        .NLIST  ME
        .NLIST  MEX
        .NLIST  BEX
;==========================================================================================
; Терминальный модуль КСМ - управляющая программа. 
;==========================================================================================
;
; Адреса устройств на общей шине
;
; 000000 - 017777 RAM с предзагруженной управляющей программой
; 140000 - 144000 - видеобуфер VGA
; 170000 - регистр адреса курсора
; 170002 - регистр управления терминалом
; 171000 - CSR клавиатуры PS/2
; 171002 - Регистр данных клавиатуры PS/2
; 177560 - CSR приемника UART
; 177562 - Регистр данных приемника UART
; 177564 - CSR передатчика UART
; 177566 - Регистр данных передатчика UART
;
;---------------------------------------------------------------------------
; Регистр управления терминалом VTCSR:
;
;   D0: 0 - локальная петля, 1 - связь с ЭВМ
;   D1: 
;   D2: 0 - курсор невидим, 1 - отображается
;   D3: форма курсора: 0 - подчеркивание, 1 - блок
;   D4: 1 - звуковой сигнал
;   D5: импульсы управления мерцанием знаков (0 - знак погашен, 1 - отображается)
;
;   D8..D10: скорость интерфейса:
;            000 - 1200
;            001 - 2400
;            010 - 4800
;            011 - 9600
;            100 - 19200
;            101 - 38400
;            110 - 57600
;            111 - 115200
;
; Адреса регистров устройств
;
TTINCSR = 177560  ; CSR приемника UART
TTINDAT = 177562  ; регистр данных приемника UART
TTOUTCSR = 177564 ; CSR передатчика UART
TTOUTDAT = 177566 ; регистр данных передатчика UART
KBCSR = 171000    ; регистр управления клавиатуры
KBDAT = 171002    ; регистр данных клавиатуры
CURPOS = 170000   ; регистр позиции курсора
VTCSR = 170002    ; регистр управления видеоконтроллером
VBUF = 140000     ; начало видеобуфера
RAMTOP = 010000   ; верхняя граница программной памяти

; биты регистра VTCSR

VC$ONL= 1       ; D0 - режим online/offline
VC$VCUR=4       ; D2 - видимость курсора
VC$FCUR=10      ; D3 - форма курсора
VC$SND=20       ; D4 - звук
VC$FLASH=40     ; D5 - импульсы мерцания символов

; Длительность звукового сигнала в тактах системного таймера 50 Гц

LSOUND = 10.

; Параметры экрана

COLS=80.               ; число столбцов
VBOT=VBUF+COLS         ; нижняя граница пользовательского экрана (начало области выводимых данных)
VTOP=VBOT+<24.*COLS>   ; верхняя граница пользовательского экрана

; Служебная строка

RLINE=VBUF           ; адрес служебной строки - начало экрана
RL.ONL=RLINE+10.     ; индикатор ONLINE
RL.CAP=RL.ONL+10.    ; индикатор CAPS
RL.ALT=RL.CAP+6.     ; индикатор ALT
RL.KOI=RL.ALT+6.     ; индикатор KOI7/RUS/LAT
RL.HLD=RL.KOI+6.     ; индикатор HOLD
RL.SCR=RL.HLD+6.     ; индикатор WAIT
RL.MUT=RL.SCR+6.     ; индикатор MUTE

RL.SPD=RLINE+62.     ; текущая скорость интерфейса
RL.TIM=RLINE+71.     ; время работы терминала
;
; Коды управляющих символов
;
HT       = 11        ; табуляция
LF       = 12        ; перевод строки
CR       = 15        ; курсор в начало строки
ESC      = 33
BS       = 10
DEL      = 177

; Префиксные сканкоды клавиатуры

P$KBEX  = 340   ; расширенные сканкоды E0
P$KBOFF = 360   ; отпускаение кнопок F0

;===========================================================================
;   Раскладка кодов символов в шрифтовом файле
;  hex     oct
; 00-1f  000-037  большие латинские буквы (для индикации управляющих кодов)
; 20-3f  040-077  цифры и обычные символы
; 40-5f  100-137  большие латинские буквы
; 60-7f  140-177  малые латинские буквы
; 80-9f  200-237  псевдографика
; a0-bf  240-277  не используется
; c0-df  300-337  малые русские буквы
; e0-ff  340-377  большие русские буквы

;*************************************************
; Макрос для генерации векторов прерываний
;*************************************************
        .MACRO    IV, ADR
        .IF     NB, <ADR>                
        .WORD    ADR            ; Если адрес обработчика указан, вписываем его
        .IFF                        
        .WORD    START        ; Если нет, то указываем START - полный перезапуск прошивки
        .ENDC                         
        .WORD    340            ; PS=340 всегда
        .ENDM                

      .ASECT

;*************************************************
; Таблица векторов прерываний
;*************************************************
      IV    START   ; 0   Вектор начального пуска
      IV    START   ; 4   Прерывание по ошибке шины
      IV            ; 10    
      IV            ; 14    
      IV            ; 20    
      IV            ; 24    
      IV            ; 30    
      IV            ; 34    
      IV            ; 40    
      IV            ; 44    
      IV            ; 50    
      IV    KBRIRQ  ; 54  Клавиатура PS/2
      IV    RXIRQ   ; 60  Приемник UART
      IV    TXIRQ   ; 64  Передатчик UART
      IV            ; 70    
      IV            ; 74    
      IV    TMRIRQ  ; 100 Интервальный таймер 50 Гц            
      
;**************************************************
;* Стартовая точка входа
;**************************************************
START:
         MOV     #RAMTOP,SP                ; стек - на верху области памяти
;
; Настройка указателей кольцевых буферов
;
         CLR     DBUFSTORE                 ; буфер данных UART 
         CLR     DBUFLOAD                   
         CLR     KBUFSTORE                 ; буфер данных клавиатуры 
         CLR     KBUFLOAD   
         
; настройка флаговых регистров        
         CLR    ESCFLAG
         MOV    #KB$CAPS,KBFLAG    ; включаем Caps Lock
         MOV    #ST$ONL,SYSFLAG    ; поднимаем флаг Online
;
; Подготовка экранного буфера
;
         CALL    CLSCREEN        ; чистим экран
;
; Чтение начальной скорости интерфейса
;
         MOV    @#VTCSR,R1
         SWAB   R1           ; переносим скорость в младший байт
         BIC    #177770,R1   ; выделяем биты 0..3 - индекс скорости
         MOV    R1,SPEED     ; сохраняем индекс скорости
;
; Включение курсора
;
         BIS    #VC$VCUR,@#VTCSR
;
; Запуск таймера задержки приема с клавиатуры
; Он нужен, чтобы пропустить переходный мусор, идущий с клавиатуры при включении  
; 
         MOV    #30.,KBTIMER  ; запускаем на 0.5с. 
;
; Подготовка таймера мерцания символов
;
         MOV    #10.,FLTIMER
;
; Настройка разрешения прерываний
;
          MOV   #100,@#TTINCSR       ; открываем прерывания от приемника уарта
          MOV   #100,@#KBCSR         ; и от клавиатуры
          MTPS  #0                   ; разрешаем прерывания процессора
;          
; выводим строку состояния
;
          CALL     RLSHOW         
         
;***********************************************
;*   Основной цикл обработки данных. 
;***********************************************

MLOOP:
         MOV    SYSFLAG,R5
         ADD    KBFLAG,R5   ; формируем хеш флагов
         CALL   KBIN        ; Обрабатываем данные с клавиатуры
         BCS    10$         ; есть данные от клавиатуры - обрабатываем их всех, вывод на экран приостанавливаем
         CALL   TTOUT       ; Обрабатываем выводимые на экран данные
10$:         
         MOV    SYSFLAG,R0
         ADD    KBFLAG,R0   ; новый хеш флагов
         CMP    R0,R5       ; флаги поменялись?
         BEQ    MLOOP       ; нет
         CALL   RLSHOW      ; обновляем строку состояния
         BR     MLOOP

;********************************************
;* Обработка выводимых на экран данных
;********************************************
TTOUT:     
; проверка на hold screen
         BIT    #ST$WAIT,SYSFLAG    ; установлен признак задержки вывода?
         BEQ    10$                 ; нет - продолжаем вывод
         BIT    #KB$SCR,KBFLAG      ; нажат scoll lock?
         BEQ    TTEMPTY             ; нет - вывод на экран не производим
; scroll нажат
         BIT     #<KB$LSHIFT!KB$RSHIFT>,KBFLAG   ; SHIFT нажат?
         BEQ    5$                  ; нет
         MOV    #23.,SDELAY         ; нажат shift+scroll - откладываем задржку на 24 строки
5$:         
         BIC    #KB$SCR,KBFLAG      ; scroll нажат - снимаем его флаг
         BIC    #ST$WAIT,SYSFLAG    ; и флаг задержки - вывод разрешен
         MOV    #21,R0              ; отсылаем XON (ctrl-q)
         CALL   UTTOUT
10$:
         CALL   DBLOAD     ; принимаем байт из уарта
         BCC    TTEMPTY    ; данных пока не поступало
         MOVB   R1,R0      ; принятый байт
         BIC    #177600,R0 ; Сбрасываем старший бит - у нас 7-битный терминал
         CALL   CHCONTROL  ; Обрабатываем управляющие коды
         TST    R0         ; обработчик вернул 0?
         BEQ    99$        ; управляющий код обработан и в видеобуфер не записывается
;
; Обработка неподдерживаемых управляющих символов в диапазоне 00-37
;
         CMP     R0,#40
         BGE     15$        ; код больше 37 - обрабатываем далее
         BR      30$        ; код до 37 просто выводим в экранный буфер
;
; Обработка режима псевдографики
;
15$:
        BIT     #ST$GRF,SYSFLAG
        BEQ     20$         ; режим отключен
        CMP     R0,#100     ; попадаем в область псевдографических символов 100-137? 
        BLT     20$         ; нет
        CMP     R0,#140
        BGE     20$
        ADD     #100,R0      ; коррекция кода символа - переводим в область 200-237
        BR      30$
;
; Обрабатываем режим koi-7
;
20$:
         BIT      #KB$KOI7,KBFLAG
         BEQ      50$        ; режим KOI7 не включен
         CMP      R0,#140    ; коды до 140 общие в обоих режимах
         BLT      30$
25$:         
         ADD      #200,R0    ; преобразуем код ASCII в KOI7: 140-177 -> 340-377
         BR       30$
;
; Обработка режимов rus-lat
;
50$:
        BIT      #KB$LANG,KBFLAG
        BEQ      30$        ; режим LAT - все коды уже на месте
        CMP      R0,#77     ; коды до 77 общие в обоих режимах
        BGE      25$        ; остальные коды переносим в русскую часть шрифта: 100-177 -> 300-377
;
; Обработка отображаемых символов
;
30$:
         MOV      TCUR,R3    ; адрес курсора
         MOVB     R0,(R3)    ; записываем байт в видеобуфер по текщему положению курсора
         MOV      R3,R2
         CALL     CLADDR     ; адрес начала текущей строки -> R3
         ADD      #<COLS-1>,R3 ; получаем адрес последнего знака текущей строки
         CMP      R2,R3      ; это текущая позиция? 
         BEQ      99$        ; да - сдвигаться некуда
         INC      R2         ; сдвигаем позицию курсора вперед
         MOV      R2,TCUR
99$:
         MOV      TCUR,@#CURPOS    ; устанавливаем аппаратный курсор в текущую позицию
TTEMPTY:
         RETURN 

;************************************
;*  Обработка спецсимволов
;************************************
CHCONTROL:
        BIT     #ESC$ON,ESCFLAG ; проверяем на активную esc-последовательность
        BEQ     4$
        CALL    ESCPROCESS      ; обрабатываем esc-последовательность
        BR      CHCDONE
4$:         
        CMPB    R0,#CR          ; 15 - CR
        BNE     6$
        CALL    BLINE
        BR      CHCDONE
;----------------------------         
6$:         
        CMPB    R0,#LF          ; 12 - LF
        BNE     12$
        CALL    LFEED
        BR      CHCDONE
;---------------------------- 
12$:
        CMPB    R0,#17          ; 17 - LAT
        BNE     15$
        BIC     #KB$LANG,KBFLAG
        BR      CHCDONE
;---------------------------- 
15$:
        CMPB    R0,#16          ; 16 - RUS
        BNE     16$
        BIS     #KB$LANG,KBFLAG
        BR      CHCDONE
;---------------------------- 
16$:
        CMPB    R0,#07          ; 07 - звуковой сигнал
        BNE     80$
        BIT     #ST$MUT,SYSFLAG ; звук разрешен?
        BNE     CHCDONE          ; нет
        MOV     #LSOUND,STIMER   ; взводим таймер
        BIS     #VC$SND,@#VTCSR  ; включаем звук
        BR      CHCDONE
;---------------------------- 
80$:
        CMPB    R0,#10          ; 10 - BS
        BNE     210$
        CALL    CLEFT
        BR      CHCDONE
;----------------------------
210$:
        CMPB    R0,#HT          ; 11 - HT, горизонтальная табуляция
        BNE     250$
        CALL    HTAB
        BR      CHCDONE
;----------------------------
250$:
        CMPB    R0,#5           ; 5 - идентификация
        BNE     102$
        CALL    IDENTIFY
        BR      CHCDONE
;----------------------------
102$:
        CMPB    R0,#ESC        ; ESC - начало esc-последовательности
        BNE     CHPASS
        BIS     #ESC$ON,ESCFLAG ; устанавливаем флаг начала последовательности
;----------------------------         
CHCDONE:
        CLR     R0         ; R0==0 - признак обработанного спецсимвола
CHPASS:
        RETURN
        
;****************************************
;* Обработка ESC-последовательностей
;****************************************
ESCPROCESS:
;
;  Обработка байтов команды ESC-Y - прямое позиционирование курсора
;
        BIT     #ESC$Y1,ESCFLAG ; идет прием второго байта ESC-Y?
        BEQ     3$              ; нет
        SUB     #40,R0
        MOV     R0,ESCY1C       ; сохраняем второй байт-40
        CALL    CURMOVE         ; производим прямое позиционирование курсора
        BIC     #ESC$Y1,ESCFLAG ; снимаем флаг Y1
        JMP     98$
3$:
        BIT     #ESC$Y0,ESCFLAG ; идет прием первого байта ESC-Y?
        BEQ     4$              ; нет
        SUB     #40,R0
        MOV     R0,ESCY0L       ; сохраняем первый байт-40
        BIC     #ESC$Y0,ESCFLAG ; снимаем флаг приема первого байта
        BIS     #ESC$Y1,ESCFLAG ; поднимаем флаг приема второго байта
        RETURN
;
; Обработка однобайтовых ESC-команд
;
4$:
        CALL    CLADDR
        CMPB    R0,#'B         ;* курсор вниз  
        BNE     5$
        CALL    CDOWN
        JMP     98$
5$:
        CMPB    R0,#'A         ;* курсор вврех
        BNE     6$
        CALL    CUP
        BR      98$
6$:    
        CMPB    R0,#'C         ;* курсор вправо
        BNE     7$
        CALL    CRIGHT
        BR      98$
7$:    
        CMPB    R0,#'D         ;* курсор влево
        BNE     8$
        CALL    CLEFT
        BR      98$
8$:    
        CMPB    R0,#'H         ;* курcор в начало экрана
        BNE     9$
        CALL    HOME
        BR      98$
9$:    
        CMPB    R0,#'Y      ;* прямое позиционирование курсора
        BNE     10$
        BIS     #ESC$Y0,ESCFLAG
        RETURN
10$:    
        CMPB    R0,#'J         ;* стирание до конца экрана
        BNE     11$
        CALL    CLREOS
        BR      98$
11$:
        CMPB    R0,#'=         ;* включить альтернативную клавиатуру
        BNE     30$
        BIS     #KB$ALT,KBFLAG
        BR      98$
30$:
        CMPB    R0,#'>        ;* отключить альтернативную клавиатуру
        BNE     40$
        BIC     #KB$ALT,KBFLAG
        BR      98$
40$:
        CMPB    R0,#'K         ;* стирание до конца строки
        BNE     20$
        CALL    CLREOL
        BR      98$
20$:    
        CMPB    R0,#'I      ;* обратный LF
        BNE     33$
        CALL    REVLF
        BR      98$
33$:
        CMPB    R0,#'Z        ;* идентификация моделей
        BNE     60$
        CALL    IDENTIFY
        BR      98$
60$:
        CMPB    R0,#'F        ;* вход в псевдографический режим
        BNE     45$
        BIS     #ST$GRF,SYSFLAG
        BR      98$
45$:
        CMPB    R0,#'G        ;* выход из псевдографического режима
        BNE     50$
        BIC     #ST$GRF,SYSFLAG
        BR      98$
50$:
        CMPB    R0,#133        ;* включение hold screen
        BNE     55$
        BIS     #ST$HLD,SYSFLAG
        MOV     #23.,SDELAY    ; устанавливаем отсрочку задержки экрана на 24 строки
        BR      98$
55$:
        CMPB    R0,#134        ;* выключение hold screen
        BNE     200$
        BIC     #KB$SCR,KBFLAG
        BIC     #<ST$HLD!ST$WAIT>,SYSFLAG
        MOV     #23.,SDELAY    ; предотвращаем дальнейшие задержки экрана
        BR      98$
200$:
;
; Все последующие коды не отрабатываются в режиме HOLD SCREEN
; 
        BIT     #ST$HLD,SYSFLAG
        BNE     98$                 
     
        CMPB    R0,#'P        ;* раздвижка строки вправо
        BNE     300$
        CALL    INSRIGHT
        BR      98$
300$:        
        CMPB    R0,#'Q        ;* раздвижка строки влево
        BNE     400$
        CALL    INSLEFT
        BR      98$
400$:        
        CMPB    R0,#'S        ;* раздвижка экрана вниз
        BNE     500$
        CALL    INSDOWN
        BR      98$
500$:        
        CMPB    R0,#'T        ;* раздвижка экрана вверх
        BNE     98$
        CALL    INSUP
98$:    
        BIC     #ESC$ON,ESCFLAG  ; снимаем флаг активной ESC-последовательности
        RETURN

;*****************************************
;* Копирование текстовых строк
;*   R0 - src
;*   R1 - dst
;*****************************************
STRCPY:
        MOVB   (R0)+,(R1)+
        TSTB   (R0)
        BNE    STRCPY
        RETURN
        
;**************************************
;* Вывод индикаторов служебной строки
;**************************************
RLSHOW:

        BIT     #KB$CAPS,KBFLAG   ;caps
        BEQ     10$
        MOV     #RLI$CAP,R0
        BR      15$
10$:    MOV     #RLI$BLK,R0
15$:    MOV     #RL.CAP,R1
        CALL    STRCPY
        
        BIT     #KB$ALT,KBFLAG    ;alt
        BEQ     20$
        MOV     #RLI$ALT,R0
        BR      25$
20$:    MOV     #RLI$BLK,R0
25$:    MOV     #RL.ALT,R1
        CALL    STRCPY
        
        BIT     #KB$KOI7,KBFLAG  ; KOI7/Rus-Lat
        BEQ     40$
        
; Режим KOI-7

        MOV     #RLI$KOI,R0
        BR      45$
40$:
; Режим  RUS-LAT
    
        BIT     #KB$LANG,KBFLAG
        BEQ     41$
        MOV     #RLI$RUS,R0
        BR      45$
41$:        
        MOV     #RLI$LAT,R0
45$:
        MOV     #RL.KOI,R1
        CALL    STRCPY
    
        BIT     #ST$ONL,SYSFLAG  ; LINE/LOCAL
        BEQ     50$
        MOV     #RLI$ONL,R0
        BR      55$
50$:    MOV     #RLI$LOC,R0
55$:    MOV     #RL.ONL,R1
        CALL    STRCPY

        BIT     #ST$HLD,SYSFLAG  ; HOLD
        BEQ     60$
        MOV     #RLI$HLD,R0
        BR      65$
60$:    MOV     #RLI$BLK,R0
65$:    MOV     #RL.HLD,R1
        CALL    STRCPY

        BIT     #ST$WAIT,SYSFLAG  ; WAIT
        BEQ     70$
        MOV     #RLI$SCR,R0
        BR      75$
70$:    MOV     #RLI$BLK,R0
75$:    MOV     #RL.SCR,R1
        CALL    STRCPY

        BIT     #ST$MUT,SYSFLAG  ; MUTE
        BEQ     80$
        MOV     #RLI$MUT,R0
        BR      85$
80$:    MOV     #RLI$BLK,R0
85$:    MOV     #RL.MUT,R1
        CALL    STRCPY
        
; вывод текущей скорости интерфейса
        MOV     SPEED,R1     ; текущая скорость
        MUL     #6,R1        ; умножаем на длину строки скорости
        ADD     #RSPEED,R1   ; получаем смещение к нужной строке скорости
        MOV     #RL.SPD,R0
        MOV     (R1)+,(R0)+  ; копируем в строку состояния
        MOV     (R1)+,(R0)+
        MOV     (R1)+,(R0)+
        RETURN
    
;****************************************
;* Идентификация моделей терминала
;****************************************
IDENTIFY:
        MOV     #ESC,R0        ; последовательность - ESC / K
        CALL    UTTOUT        ; в буфер
        MOV     #'/,R0
        CALL    UTTOUT
        MOV     #'K,R0
        CALL    UTTOUT
        RETURN

;***********************************************************
;*  раздвижка строки вправо
;***********************************************************
INSRIGHT:
        ADD     #80.,R3        ; R3 = адрес первого байта следующей строки
        MOV     TCUR,R0        ; текущий адрес курсора
        INC     R0             ; R0 = адрес следующего за курсором байта
        CMP     R0,R3
        BEQ     LRTN           ; курсор стоит в конце строки - команда не выполняется
        MOV     R3,R2
        DEC     R2             ; R2=адрес предпоследнего байта текущей строки
        CMP     R0,R2
        BEQ     CHRCLR         ; курсор стоит на предпоследнем байте строки - просто очищаем последний байт
10$:
        MOVB    -(R2),-(R3)    ; сдвигаем вперед хвост строки от курсора до конца строки,
                               ; начиная от конца строки 
        CMP     R2,R0          ; доехали до позиции курсора? 
        BNE     10$            ; нет
CHRCLR:        
        MOVB    #' ,(R0)       ; вставляем пробел в точку разрыва 
        RETURN

;***********************************************************
;*  раздвижка строки влево
;***********************************************************
INSLEFT:
        MOV     TCUR,R0        ; текущий адрес курсора
        MOV     R3,R2          ; R3 = адрес начала строки
        CMP     R0,R3
        BEQ     LRTN           ; курсор стоит в начале строки - команда не выполняется
        DEC     R0             ; R0 -> байт перед курсором
        CMP     R0,R3
        BEQ     CHRCLR         ; курсор стоит на втором байте строки - просто очищаем первый байт
        INC     R2             ; R2 = второй символ строки
10$:
        MOVB    (R2)+,(R3)+    ; сдвигаем байты влево от начала строки до курсора 
        CMP     R3,R0          ; доехали до курсора?
        BNE     10$            ; нет
        BR      CHRCLR

;***********************************************************
;*  раздвижка строк вверх
;***********************************************************
INSUP:
        MOV     #VBOT,R0       ; первая строка видеобуфера
        CMP     R3,R0          ; текущая строка - первая?
        BEQ     LRTN           ; да - команда не выполняется. Раздвигать нам нечего.
        MOV     R0,R1
        ADD     #80.,R1        ; R1=вторая cтрока видеобуфера
        CMP     R1,R3          ; вторая строка = текущая?
        BNE     10$            ; нет
        MOV     R0,R3          ; R3=адрес первой строки буфера
        BR      LINCLR         ; вторая строка - текущая, просто очищаем первую строку
10$:
        MOV     (R1)+,(R0)+    ; переносим весь видеобуфер на строку назад
        CMP     R1,R3          ; до текущей строки
        BNE     10$
        SUB     #80.,R3        ; начало предыдущей строки
LINCLR:    
        MOV     #40.,R1        ; длина строки - 40 слов
10$:        
        MOV     #20040,(R3)+   ; заполняем предыдущую строку пробелами
        SOB     R1,10$
LRTN:        
        RETURN
        
;***********************************************************
;*  раздвижка строк вниз
;***********************************************************
INSDOWN:
        ADD     #80.,R3        ; R3 = адрес начала следующей (после текущей) строки
        MOV     R3,R2
        MOV     #VTOP,R0       ; R0 = вершина видеобуфера
        CMP     R2,R0          ; текущая строка - последняя?
        BEQ     LRTN           ; да - команда не выполняется
        MOV     R2,R1
        ADD     #80.,R1        ; R1 = вторая от текущей строка
        CMP     R1,R0          ; она текущая?
        BNE     10$            ; нет
        BR      LINCLR         ; текущая строка - предпоследняя, просто очищаем последнюю строку
10$:
        MOV     (R2)+,(R1)+    ; переносим строки от следующей до вершины видеобуфера на строку вперед
        CMP     R0,R2          ; до текущей строки
        BNE     10$
        BR      LINCLR
        
;****************************************
;*  Очистка от курсора до конца экрана
;****************************************
CLREOS:
        MOV     TCUR,R3
10$:
        MOVB    #40,(R3)+      ; заполняем буфер проблеами
        CMP     R3,#VTOP       ; до верхней границы
        BNE     10$
        RETURN

;****************************************
;*  Очистка от курсора до конца строки
;****************************************
CLREOL:
        MOV     TCUR,R4  
        CALL    CLADDR          ; адрес начала строки
        ADD     #COLS,R3        ; адрес последнего байта строки
10$:
        MOVB    #40,(R4)+       ; вписываем пробелы
        CMP     R4,R3           ; до конца строки
        BNE     10$
        RETURN
    
;**************************************
;* Прямое позиционирование курсора
;**************************************
CURMOVE:
        MOV     ESCY0L,R1     ; байт 1 - номер строки
; проверяем, не вышел ли номер строки за пределы экрана        
        CMP     R1,#24.
        BLT     4$
; номер строки выходит за пределы экрана - не делаем горизонтальное перемещение
        CALL    CLADDR        ; адрес начала строки -> R3
        SUB     #VBOT,R3      ; получаем смещение от начала экрана до начала строки
        MOV     R3,R1
        BR      10$
4$:
        MUL     #COLS,R1      ; умножаем на длину строки    
10$:
        MOV     ESCY1C,R0     ; байт 2 - номер позиции
        CMP     R0,#COLS      ; проверяем его
        BLT     20$           
        MOV     #COLS,R0      ; позиция превышает длину строки - встаем на правую границу строки
20$:
        ADD     R0,R1         ; добавляем к адресу начала строки
        ADD     #VBOT,R1      ; + начальный адрес экрана
        MOV     #VTOP,R0      ; верхняя граница
        CMP     R1,R0
        BGE     50$           ; выход за границу видеобуфера
        MOV     R1,TCUR
50$:    RETURN    
    
;*************************
;* BS - курсор назад
;*************************
CLEFT:
        CALL    CLADDR      ; ->R3
        CMP     TCUR,R3     ; курсор стоит в начале строки?
        BEQ     10$         ; да - игнорируем команду
        DEC     TCUR        ; сдвигаем курсор на символ назад
10$:    RETURN

         
;******************************
;* скролл экрана вверх
;******************************
SCRLUP:
        BIT     #ST$HLD,SYSFLAG  ; режим HOLD Screen ?
        BEQ     100$            ; HOLD выключен
        TST     SDELAY          ; счетчик задержки 
        BEQ     50$             ; задержки нет
        DEC     SDELAY          ; уменьшаем счетчик 
        BR      100$            ; и продолжаем обработку скролла
50$:        
        BIS     #ST$WAIT,SYSFLAG ; поднимаем признак задержки экрана
        MOV     #23,R0          ; отправляем Xoff (ctrl/s)
        CALL    UTTOUT

100$:           
        MOV     #VBOT+COLS,R1    ; R1 = адрес начала строки 1
        MOV     #VBOT,R2         ; R2 = адрес начала строки 0    
        MOV     #VTOP,R4         ; R4 = адрес конца последней строки
102$:
        MOV     (R1)+,(R2)+      ; перемещаем весь видеобуфер на строку назад
        CMP     R1,R4
        BNE     102$
101$:           
        MOV     #20040,(R2)+    ; очищаем последнюю строку
        CMP     R2,R4
        BNE     101$
        RETURN

;******************************
;* скролл экрана вниз
;******************************
SCRLDWN:
        MOV     #VTOP,R1      ; верхняя граница видеобуфера
        MOV     R1,R2
        SUB     #COLS,R2      ; адрес начала последней строки экрана
100$:           
        MOV     -(R2),-(R1)   ; перемещаем весь видеобуфер на строку назад
        CMP     R2,#<VBOT>    ; доехали до начала буфера?
        BNE     100$          ; нет 
        MOV     #VBOT,R2      ; начало видеобуфера
101$:           
        MOV     #20040,(R2)+    ; очищаем первую строку
        CMP     R2,#<VBOT+COLS>
        BNE     101$
        RETURN

;*****************************************
; Reverse LF - строка вверх со скроллом
;*****************************************
REVLF:
        CMP     TCUR,#VBOT+COLS ; мы стоим на первой строке?
        BLT     10$                ; да - скролл вниз
        SUB     #COLS,TCUR         ; иначе просто сдвигаем курсор на строку вверх
        RETURN
10$:
        CALL     SCRLDWN
        RETURN
     
;*************************************
;* LF - строка вниз (со скроллом)
;*************************************
LFEED:
        MOV     TCUR,R3
        MOV     #VTOP,R0
        SUB     #COLS,R0
        CMP     R3,R0               ; доехали до границы буфера?
        BLT     10$                 ; нет - просто сдвигаем курсор вниз
30$:     
        CALL    SCRLUP              ; скролл вверх
        RETURN
10$:
        ADD     #COLS,R3     ; Добавляем длину строки к номеру строки
        MOV     R3,TCUR
        RETURN
         
;*******************************
;* Курсор вниз (без скролла)
;*******************************
CDOWN:
        MOV     TCUR,R3
        MOV     #VTOP,R0      ; верхняя граница видеобуфера
        SUB     #COLS,R0      ; адрес начала последней строки
        CMP     R3,R0         ; курсор стоит на последней строке?
        BGE     10$           ; да - игнорируем команду
        ADD     #COLS,R3      ; сдвигаем курсор на строку вниз
        MOV     R3,TCUR
10$:    RETURN    

;*******************************
;* Курсор вверх (без скролла)
;*******************************
CUP:
        MOV     TCUR,R3            
        CMP     R3,#VBOT+COLS     ; курсор стоит на первой строке?
        BLT     10$               ; да - игнорируем команду
        SUB     #COLS,R3          ; иначе сдвигаем курсор вверх на строку
        MOV     R3,TCUR
10$:    RETURN    

;*******************************
;* Курсор вправо
;*******************************
CRIGHT:
        ADD    #79.,R3
        CMP    TCUR,R3   ; курсор стоит на последнем байте строки?
        BEQ    10$       ; да - команда игнорируется
        INC    TCUR      ; сдвигаем курсор на символ вперед
10$:    RETURN


;**************************************************         
;* Получение адреса начала текущей строки -> R3
;**************************************************         
CLADDR:
         MOV    R0,-(SP)
         MOV    TCUR,R1        ; текущий адрес курсора
         SUB    #VBOT,R1       ; смещение от начала видеобуфера до курсора
         CLR    R0             
         DIV    #COLS,R0       ; делим на число столбцов
         MOV    R0,R3          ; результат деления (остаток отбрасываем)
         MUL    #COLS,R3       ; умножаем на число столбцов - получаем смещение до первого столбца строки
         ADD    #VBOT,R3       ; добавляем адрес начала видеобуфера
         MOV    (SP)+,R0
         RETURN

;**********************************         
;* CR - курсор в начало строки         
;**********************************
BLINE:
        CALL    CLADDR          ; адрес начала строки -> R3
        MOV     R3,TCUR         
        RETURN

;***************************
;* Очистка видеобуфера
;***************************
CLSCREEN:
        MOV     #VBUF,R0
1$:
        MOV     #20040,(R0)+     ; Заполняем видеобуфер пробелами
        CMP     R0,#VTOP         ; верхняя физическая граница видеобуфера
        BNE     1$

;************************************
;*  Курсор - в верхний левый угол
;************************************
HOME:
         MOV     #VBOT,R3       ; начало видеобуфера
         MOV     R3,TCUR
         MOV     R3,@#CURPOS    ; устанавливаем аппаратный курсор в текущую позицию
         RETURN

;************************************
;* Горизонтальная табуляция
;************************************
HTAB:
        CALL    CLADDR      ; адрес начала строки ->R3
        ADD     #79.,R3     ; адрес последнего байта строки
        CMP     TCUR,R3     ; если кусор стоит на нем - ничего не делаем
        BNE     10$
        RETURN
10$:    
        SUB     #7,R3       ; адрес байта 72 текущей строки
        CMP     TCUR,R3     ; курсор стоит в позиции 72 или выше?
        BLT     30$         ; нет
        INC     TCUR        ; для позиций 72-78 просто сдвигаем курсор вперед
        RETURN
30$:    
        BIS        #7,TCUR  ; Выходим на следующую полизию кратную 8
        INC     TCUR
        RETURN
             
;**************************************************************
;* Загрузка байта из буфера входящих (дисплейных) данных
;**************************************************************
DBLOAD:
;        MTPS   #200                      ; Запрещаем все прерывания
         MOV    DBUFLOAD,R0               ; указатель чтения буфера
         MOV    DBUFSTORE,R1              ; указатель хвоста буфера
         CMP    R0,R1                     ; совпадают?
         BNE    10$                       ; нет
         MTPS   #0                        ; открываем прерывания, C=0
         RETURN
;
; Буфер не пуст
;
10$:
         INC    R0                        ; Продвигаем указатель
         BIC    #177700,R0                ; заворот на границу буфера
         MOV    R0,DBUFLOAD               ; сохраняем указатель
         ADD    #DBUF,R0                  ; добавляем адрес начала буфера
         MOVB   (R0),R1                   ; загружаем текущий байт из буфера
         MTPS   #1                        ; открываем прерывания, C=1
         RETURN


;=======================================
;========    Модуль клавиатуры ===============================================================================                
;=======================================

;****************************************************************
;* Загрузка данных из буфера клавиатуры 
;*   R1 - выходной байт
;*   R0=0 - буфер пуст, R1=1 - принят байт
;****************************************************************
KBLOAD:
         MTPS  #200                      ; Запрещаем все прерывания
         MOV   KBUFLOAD,R0               ; 
         MOV   KBUFSTORE,R1              ; указатель чтения буфера
         CMP   R0,R1                     ; указатель хвоста буфера
         BNE   10$                       ; совпадают?
         CLR   R0                        ; Нет
         BR    90$                       
10$:          
         INC   R0                        ; Продвигаем указатель
         BIC   #177770,R0
         MOV   R0,KBUFLOAD               ; сохраняем указатель
         ADD   #KBDBUF,R0                ; добавляем адрес начала буфера
         CLR   R1
         MOVB  (R0),R1                   ; загружаем текущий байт из буфера
90$:
         MTPS   #0                       ; открываем прерывания
         RETURN
;*****************************************************************
;*  Обработка отпускания кнопок-модификаторов
;*****************************************************************
KBSTDOFF:
         CMPB  R1,#24                   ; правый CTRL
         BNE   14$
         BIC   #KB$LCTRL,KBFLAG
14$:
         CMPB  R1,#22                   ; Левый SHIFT
         BNE   18$
         BIC   #KB$LSHIFT,KBFLAG
18$:
         CMPB  R1,#131                  ; Правый SHIFT
         BNE   20$
         BIC   #KB$RSHIFT,KBFLAG
20$:
         RETURN

;*****************************************************************
;*  Обработка нажатия кнопок-модификаторов
;*****************************************************************
KBMODON:
         CMPB   R1,#24                   ; левый CTRL
         BNE    14$
         BIS    #KB$LCTRL,KBFLAG
         JMP    98$
14$:
         CMPB   R1,#22                   ; Левый SHIFT
         BNE    18$
         BIS    #KB$LSHIFT,KBFLAG
         JMP    98$
18$:
         CMPB   R1,#131                  ; Правый SHIFT
         BNE    81$
         BIS    #KB$RSHIFT,KBFLAG
         JMP    98$
81$:
         CMPB   R1,#176                  ; Scroll lock
         BNE    400$
         BIS    #KB$SCR,KBFLAG
         JMP    98$
400$:         
         CMPB   R1,#170                  ; F11 - KOI7
         BNE    300$
         BIT    #KB$KOI7,KBFLAG
         BNE    35$
; переход rus/lat -> koi7          
         BIS     #KB$KOI7,KBFLAG    ;  поднимаем флаг кои7
         BIC     #KB$CAPS,KBFLAG    ;  отключаем капслок - включается латинский регистр
         BR      98$
35$:        
; переход koi7 -> rus/lat        
         BIC     #KB$KOI7,KBFLAG  ; снимаем флаг кои7
         BIS     #KB$CAPS,KBFLAG  ; включаем капслок - большие буквы
         BIC     #KB$LANG,KBFLAG  ; по умолчанию режим LAT, латинские буквы
         BR      98$
300$:
         CMPB    R1,#21              ; левый ALT - RUS/LAT
         BNE     140$
         BIT     #KB$LANG,KBFLAG   ; проверяем текущий регистр
         BNE     308$              ; текущий - русский
; переход лат -> рус
         MOV     #16,R0    ; 16 - русский регистр
         BR      309$
308$:          
; переход лат -> рус
         MOV     #17,R0    ; 17 - латинский регистр
309$:
        CALL     UTTOUT    ; отправляем код  в порт
        BR       98$
140$:
        CMPB     R1,#3                  ; F5 - скорость--
        BNE      150$
        DEC      SPEED
155$:
; установка новой скорости в регистр управления
        MOV      SPEED,R1       ; новый индекс скорости 
        BIC      #177770,R1     ; выделяем значащие биты, заворачиваем при переполнении
        MOV      R1,SPEED       ; обновляем локально сохраненный индекс  
        MOV      @#VTCSR,R0     
        SWAB     R0
        BIC      #7,R0
        BISB     R1,R0
        SWAB     R0
        MOV      R0,@#VTCSR
        BR       98$
        
150$:        
        CMPB     R1,#13                  ; F6 - скорость++
        BNE      40$
        INC      SPEED
        BR       155$

40$:
        CMPB     R1,#130                 ; CAPS LOCK
        BNE      130$
        MOV      #KB$CAPS,R1
        XOR      R1,KBFLAG
        BR       98$
130$:
        CMPB     R1,#203                 ; F7 - форма курсора
        BNE      250$
        MOV      #VC$FCUR,R1          
        XOR      R1,@#VTCSR              ; инвертируем бит формы курсора
        BR       98$

250$:
        CMPB     R1,#12                  ; F8 - мерцание курсора
        BNE      190$
        MOV      #ST$BLINK,R1          
        XOR      R1,SYSFLAG              ; инвертируем флаг мерцания
        BIS      #VC$VCUR,@#VTCSR        ; делаем курсор видимым
        BR       98$

190$:
        CMPB     R1,#9.                  ; F10 - Online
        BNE      330$
        BIT      #ST$ONL,SYSFLAG
        BEQ      53$
        BIC      #ST$ONL,SYSFLAG
        BIC      #VC$ONL,@#VTCSR
        BR       98$
53$:    
        BIS      #ST$ONL,SYSFLAG     
        BIS      #VC$ONL,@#VTCSR
        BR       98$
        
330$:   
        CMPB     R1,#1                 ; F9 - отключение звука
        BNE      99$
        MOV      #ST$MUT,R1
        XOR      R1,SYSFLAG
; выход при обработанном коде
98$:
        CLC
        RETURN
; выход, если код не обработан        
99$:
        SEC
        RETURN

;*****************************************************************
;*  Обработка двухбайтовых кодов при нажатии управляющих кнопок
;*****************************************************************
KBEXON:
         CMPB   R1,#24                   ; правый CTRL
         BNE    10$
         BIS    #KB$RCTRL,KBFLAG
10$:
         CMPB   R1,#21                   ; правый ALT - LF
         BNE    20$
         MOV    #LF,R0       ; выводим код LF в порт
         CALL   UTTOUT
20$:
         RETURN

;********************************************************************
;*  Обработка двухбайтовых кодов при отпускании управляющих кнопок
;********************************************************************
KBEXOFF:
         CMPB   R1,#24                   ; правый CTRL
         BNE    10$
         BIC    #KB$RCTRL,KBFLAG
10$:     RETURN
         
         
;*****************************************************************
;* Обработка двухбайтовых расширенных кодов E0 xx
;*****************************************************************
KB2B:
         BIT     #KB$OFF,KBFLAG        ; установлен режим расширенного отпускания? 
         BEQ     120$                  ; нет

; режим расширенного отпускания 

         CALL    KBEXOFF         ; обрабатываем расширенные коды отпускания
         BR      98$  
         
; режим расширенного нажатия

120$:     
        CMPB     R1,#P$KBOFF      ; Это префикс отпускания?
        BNE      130$             ; нет
        BIS      #KB$OFF,KBFLAG   ; устанавливаем флаг отпускания
        RETURN
130$:     
        CALL     KBEXON         ; обрабатываем префиксные кнопки
        MOV      #EVESC,R2      ; таблица ESC-последовательностей для двухбайтовых сканкодов
        CALL     KBESC
98$:
        BIC      #<KB$EXT!KB$OFF>,KBFLAG ; снимаем флаг расширенных кодов и отпускания
        RETURN        

;*****************************************************************
;* Обработка кодов, генерирующих ESC-последовательности
;* R1 - сканкод
;* R2 - адрес таблицы кодов
;*  --> C=0 код обработан 
;*      C=1 код не найден
;*****************************************************************
KBESC:
        CMPB     (R2),R1      ; сканкод из таблицы - наш код?
        BNE      50$          ; нет
        INC      R2           ; R2 -> esc-последовательность из таблицы
        BIT      #KB$ALT,KBFLAG ; мы в режиме альтернативной клавиатуры?
        BEQ      10$            ; нет 
        ADD      #2,R2          ; сдвигаем указатель к таблице альтернативных esc-последовательностей
10$:    CALL     ESCSEND        ; выводим последовательность в порт
        CLC                     ; код обработан
        RETURN
50$:
        ADD      #5,R2       ; переходим к следующему элементу таблицы
        TSTB     (R2)        ; конец таблицы?
        BNE      KBESC       ; нет
        SEC                  ; код не обработан
        RETURN
     

;*****************************************************************
;* Обработка байтов, поступающих из порта клавиатуры
;*****************************************************************
KBIN:
        CALL    KBLOAD       ; получаем сканкод с клавиатуры -> R1
        TST     R0
        BNE     199$        
        CLC                  ; пока с клавиатуры ничего не поступало
        RETURN

199$:
        BIT     #KB$EXT,KBFLAG  ; идет обработка расширенных кодов?
        BEQ     100$            ; нет
        CALL    KB2B            ; обрабатываем двухбайтовые сканкоды  
        BR      KBEXIT

; Обработка однобайтовых кодов    

100$:    
        BIT     #KB$OFF,KBFLAG    ; мы находимся в режиме отпускания?
        BEQ     120$              ; нет
        CALL    KBSTDOFF          ; обрабатываем отпускания
        BIC     #KB$OFF,KBFLAG
        BR      KBEXIT

120$:    
        CMPB    R1,#P$KBEX       ; принят расширенный префикс Е0?
        BNE     130$
        BIS     #KB$EXT,KBFLAG   ; поднмаем флаг для принятия второго кода последовательности
        BR      KBEXIT
     
130$:
        CMPB    R1,#P$KBOFF     ; принят код отпускания?
        BNE     150$            ; нет
        BIS     #KB$OFF,KBFLAG  ; поднимаем флаг стандартного отпускания
        BR      KBEXIT            

; Обработка однобайтовых сканкодов нажатия

150$:     
         MOV    #SVESC,R2         ; таблица управляющих однобайтовых кодов
         CALL   KBESC             ; попытка обработки такого кода 
         BCC    KBEXIT            ; Код обработан - на выход
                  
         CALL   KBMODON           ; обрабатываем коды кнопок-модификаторов 
         BCC    KBEXIT            ; модификатор обработан

         CMP    R1,#167           ; коды выше 166 (ESC) не обрабатываем
         BGE    KBEXIT              

; Поиск сканкода в таблице      
155$:
         MOV     #SCTAB,R0     ; таблица сканкодов
410$:
         TSTB    (R0)          ; конец таблицы?
         BEQ     KBEXIT        ; да - обработуц прекращаем
         CMPB    (R0),R1       ; это наш код?
         BEQ     500$          ; да - идем его обрабатывать              
         ADD     #9.,R0        ; переходим к следующей строке таблицы
         BR      410$
500$:                          
         INC     R0            ; R0 -> тело строки таблицы
         MOV     R0,R1

; Проверка режима ctrl         
         BIT     #<KB$LCTRL!KB$RCTRL>,KBFLAG ; CTRL нажат?
         BEQ     60$               ; нет
         ADD     #ST.CTRL,R1       ; выбираем поле ctrl таблицы
         MOVB    (R1),R0           ; выбираем байт из таблицы
         CMPB    #377,R0           ; такого ctrl-кода не существует?
         BEQ     KBEXIT            ; да - прекращаем обработку                                  
         BR      400$              ; иначе выводим код в интерфейс                           
60$:
;
;  Подготовка слова состояния клавиатуры для поиска в таблице вариантов сканкода
;
         CLR     R0                 ; сюда будут собираться биты режима
         BIT     #KB$KOI7,KBFLAG                                 
         BNE     310$               ; текущий режим - KOI7   
         BIT     #KB$LANG,KBFLAG
         BEQ     10$                ; режим латинских букв
; режим русских букв         
         BIS     #KM.RUS,R0         ; поднимаем бит русского режима
         BR      320$               ; идем проверять флаг CR
; режим KOI7         
310$:
         BIS     #KM.KOI,R0         ; поднимаем бит KOI7
320$:         
         BITB    #F$CR,ST.FLAG(R1)  ; проверка флага CR
         BEQ     1125$              ; 0
         BR      1130$              ; 1
; режим латинских букв         
10$: 
         BITB    #F$CL,ST.FLAG(R1)  ; проверяем флаг CL
         BEQ     1125$              ; 0
; формирование бита CLR на основе предыдущего анализа флагов CR/CL         
1130$:         
         BIS     #KM.CLR,R0
1125$:
         BIT     #<KB$LSHIFT!KB$RSHIFT>,KBFLAG   ; нажат SHIFT ?
         BEQ     15$               ; нет
         BIS     #KM.SHIFT,R0      ; поднимаем бит shift
15$:
         BIT     #KB$CAPS,KBFLAG   ; режим CAPS?
         BEQ     20$               ; нет
         BIS     #KM.CAPS,R0       ; поднимаем бит caps
20$:
         CLR     R2
         ADD     #KSELTAB,R0      ; добавляем адрес таблицы выбора к полученному битовому полю
         MOVB    (R0),R2          ; выбираем из таблицы номер используемой колонки сканкодов
         
;++++++ отладочный код - выводит номер колонки в 5 знакоместо служебной строки +++++         
;         MOV     R2,R0
;         ADD     #'0,R0
;         MOVB    R0,@#VBUF+5
;+++++++++++         
         
         ADD     R2,R1           ; R1 теперь указывает на код символа, соответствующего нашему сканкоду
         MOVB    (R1),R0         ; выбираем этот байт из таблицы
         TSTB    R0              ; Коды 00 - это отсутствие символа, связанного со сканкодом
         BEQ     KBEXIT          ; нулевые коды игнорируем 
400$:
         CALL    UTTOUT          ; выводим полученный знак в порт
KBEXIT:         
         SEC                     ; признак обработанного сканкода
         RETURN
         
;******************************************************
;* Вывод байта в порт UART
;******************************************************
UTTOUT:
         BIT     #200,@#TTOUTCSR    ; ждем готовности передатчика
         BEQ     UTTOUT
         MOVB    R0,@#TTOUTDAT      ; выводим байтв регистр данных
         RETURN

;******************************************************
;* Вывод ESC-последовательности в порт UART 
;* Последовательность состоит из 1 или 2 байтов
;*   R2 - адрес массива из одного или двух байтов,
;*        вторые нулевые байты не выводятся
;*
;*      Если первый байт имеет единичный старший бит,
;*      то выводится только он, без ESC
;******************************************************
ESCSEND:
         BITB    #200,(R2)       ; флаг вывода без ESC установлен
         BEQ     10$             ; нет
         MOVB    (R2),R0         ; код из таблицы
         BICB    #200,R0         ; снимаем флаговый бит
         CALL    UTTOUT          ; и выводим код в порт
         RETURN
10$:         
         MOVB    #ESC,R0         ; выводим ESC
         CALL    UTTOUT
         MOVB    (R2)+,R0        ; выводим первый байт из таблицы
         CALL    UTTOUT
         MOVB    (R2)+,R0        ; второй байт из таблицы
         BEQ     99$             ; код 0 не выводим
         CALL    UTTOUT          
99$:     
         RETURN
         
;*************************************************************
;* Обработчик прерывания от приемника UART DL11
;*************************************************************
RXIRQ:
         TSTB    @#TTINCSR              ; Проверяем бит 7 CSR - признак наличия принятого байта
         BPL     90$                    ; PL- разряд равен 0, нет принятых данных
         
         MOV     R0,-(SP)               
         MOV     R1,-(SP)               

         MOV     DBUFSTORE,R0           ; Указатель записи
         MOV     DBUFLOAD,R1            ; Указатель чтения
         INC     R0                     ; продвигаем указатель записи
         BIC     #177700,R0
         CMP     R0,R1                  ; Указатели совпадают?
         BEQ     80$                    ; Да - переполнение буфера, отбрасываем принятый байт

         MOV     R0,DBUFSTORE           ; сохраняем указатель
         MOVB    @#TTINDAT,R1           ; Принимаем байт из регистра данных UART
         ADD     #DBUF,R0               ; Добавляем адрес буфера
         MOVB    R1,(R0)                ; сохраняем байт в буфер

80$:
         MOV     (SP)+,R1               
         MOV     (SP)+,R0               
90$:
         MOV     #100,@#TTINCSR             ; Поднимаем бит разрешения прерывания
         RTI

;********************************************
;* Обработка прерывания от передатчика UART
;********************************************
TXIRQ:
         RTI

;**************************************************
;* Обработка прерывания от приемника клавиатуры
;**************************************************
KBRIRQ:
         TSTB    @#KBCSR                ; Проверяем бит 7 CSR - признак наличия принятого байта
         BPL     90$                    ; PL- разряд равен 0, нет принятых данных
         
         MOV     R0,-(SP)                 
         MOV     R1,-(SP)                 
         MOV     R2,-(SP)                 
         MOVB    @#KBDAT,R0             ; Принимаем байт из регистра данных 
         TST     KBTIMER                ; таймер задержки обнулен?
         BNE     10$                    ; нет - обходим запись байта в буфер
         CALL    KBSTORE                ; иначе записываем сканкод
10$:         
         MOV     (SP)+,R2                 
         MOV     (SP)+,R1                 
         MOV     (SP)+,R0                 
90$:
         MOV     #100,@#KBCSR           ; Поднимаем бит разрешения прерывания
         RTI

;********************************************
;* Обработка прерывания от таймера
;********************************************
TMRIRQ:
        INCB     TTICK            ; счетчик тактов таймера
        CMPB     TTICK,#50.       ; 50 тактов - секунда
        BNE      600$             ; еще не набралось 50 тактов
        CLRB     TTICK            ; заворачиваем счетчик тактов
;
;  Счетчики времени работы терминала
; 
        INCB     TSEC             ; секунды
        CMPB     TSEC,#60.        ; считаем до 60
        BNE      500$
        CLRB     TSEC
                
        INCB     TMIN             ; минуты
        CMPB     TMIN,#60.
        BNE      500$
        CLRB     TMIN
                
        INCB     THOUR            ; часы
        CMPB     THOUR,#100.      ; считаем до 100
        BNE      500$
        CLRB     THOUR
500$:
; 
; вывод текущего времени в строку состояния
;
        MOV      R0,-(SP)
        MOV      R1,-(SP)
        MOV      R2,-(SP)
        MOV      #RL.TIM,R2      ; позиция часов в строке состояния
        MOVB     THOUR,R1        ; выводим час
        CALL     PDEC
        MOVB     #':,(R2)+
        MOVB     TMIN,R1         ; минуты
        CALL     PDEC
        MOVB     #':,(R2)+
        MOVB     TSEC,R1         ; секунды
        CALL     PDEC
        MOV      (SP)+,R2
        MOV      (SP)+,R1
        MOV      (SP)+,R0
600$:
;
; Реализация мерцания курсора
; 
        BIT      #ST$BLINK,SYSFLAG    ; курсор не мерцает?
        BNE      700$                ; да, обходим таймер
        INC      CTIMER              ; таймер мерцания
        BIC      #177760,CTIMER      ; считает от 0 до 15
        BNE      700$                ; пока не досчитал
        MOV      R1,-(SP)
        MOV      #VC$VCUR,R1         
        XOR      R1,@#VTCSR          ; переключаем видимость курсора
        MOV      (SP)+,R1
;
;  Таймер звукового сигнала
;
700$:   
        TST      STIMER              ; таймер работает?
        BEQ      800$                ; нет
        DEC      STIMER              ; уменьшаем счетчик
        BNE      800$                ; еще не 0
        BIC      #VC$SND,@#VTCSR     ; доехали до 0 - отключаем звук
800$:        
;
; Таймер задержки запуска клавиатуры
;
        TST      KBTIMER
        BEQ      900$                ; считаем до 0, счетчик не перезапускается
        DEC      KBTIMER
;
; Таймер мерцания символов
;
900$:
        TST      FLTIMER             ; досчитали до 0?
        BNE      950$                ; нет
        MOV      #10.,FLTIMER        ; перезапускаем таймер 
        MOV      R0,-(SP)
        MOV      #VC$FLASH,R0        ; бит сигнала мерцания
        XOR      R0,@#VTCSR          ; инвертируем его в регистре управления
        MOV      (SP)+,R0
950$:           
        DEC      FLTIMER             ; просто уменьшаем счетчик таймера
1000$:        
        RTI

;*************************************************************
;*  Преобразование байта в 2 десятичные цифры в коде ascii
;*
;*    R1  - байт-аргумент
;*    R2  - адрес буфера результата
;*************************************************************
PDEC:
        BIC     #177600,R1      ; выделяем младшие 7 бит
        CLR     R0
        DIV     #10.,R0         ; делим (R0:R1) на 10
        ADD     #60,R0          ; частное - переводим в цифру
        MOVB    R0,(R2)+        ; выводим в выходную строку 
        ADD     #60,R1          ; остаток
        MOVB    R1,(R2)+
        RETURN
        
;******************************************************
;*  Запись байта из R0 в кольцевой буфер клавиатуры
;******************************************************
KBSTORE:
         MOV     KBUFSTORE,R2          ; Указатель записи
         MOV     KBUFLOAD,R1           ; Указатель чтения
         INC     R2                    ; продвигаем указатель записи
         BIC     #177770,R2              ; заворот по границе буфера
         CMP     R2,R1                 ; Указатели совпадают?
         BEQ     80$                   ; Да - переполнение буфера, отбрасываем принятый байт
         MOV     R2,KBUFSTORE          ; сохраняем указатель
         ADD     #KBDBUF,R2            ; Добавляем адрес буфера
         MOVB    R0,(R2)               ; сохраняем байт в буфер

80$:     RETURN
         
;==================================================
;  Сегмент данных
;==================================================
SPEED:     .WORD   0   ; индекс скорости интерфейса
;
; Указатели кольцевых буферов
;
DBUFSTORE: .WORD 0
DBUFLOAD:  .WORD 0
KBUFSTORE: .WORD 0
KBUFLOAD:  .WORD 0
;
; Флаги состояния клавиатуры
;
KBFLAG:       .WORD    0
KB$OFF=1                   ; 0 - Признак начала последовательности отпускания (код F0)
KB$EXT=2                   ; 1 - Признак расширенного кода E0
KB$ALT=4                   ; 2 - Режим альтернативной клавиатуры
KB$LCTRL=10                ; 3 - левый CTRL нажат
KB$RCTRL=20                ; 4 - правый CTRL нажат
KB$LSHIFT=40               ; 5 - Левый SHIFT нажат                      
KB$RSHIFT=100              ; 6 - Правый SHIFT нажат
KB$CAPS=200                ; 7 - Режим CAPS LOCK
KB$SCR=400                 ; 8 - Scroll Lock нажат
KB$KOI7=1000               ; 9 - 0 - режим R/L (большие и малые русские-латинские)
                           ;     1 - КОИ7 (только большие русские-латинские)
KB$LANG=2000               ; 10 - текущий языковый набор, в режиме koi7 игнорируется
                           ;     0 - латинские буквы
                           ;     1 - русские буквы
;                           
; Флаги управления системой
;
SYSFLAG:   .WORD    0
ST$MUT=2                   ; 1 - отключение звукового сигнала
ST$ONL=4                   ; 2 - Режим Online
ST$GRF=10                  ; 3 - псевдографический режим
ST$HLD=20                  ; 4 - hold screen
ST$WAIT=40                 ; 5 - вывод на экран приостановлен
ST$BLINK=100               ; 6 - режим курсора, 0 - мигает, 1 - не мигает

; адрес курсора в видеобуфере
TCUR:     .WORD    0        

; флаги обработки ESC-последовательностей

ESCFLAG:  .WORD  0        
ESCY0L:   .WORD  0          ; параметр 1 команды ESC-Y
ESCY1C:   .WORD  0          ; параметр 2 команды ESC-Y

ESC$ON=1   ; начало ESC-последовательности  
ESC$Y0=2   ; начало ESC-Y-последовательности
ESC$Y1=4   ; продолжение ESC-Y-последовательности

; Счетчик сдвигов строк перед задержкой hold screen
SDELAY:  .WORD  0

; Счетчики подсистемы таймера
TTICK:   .BYTE  0    ; счетчик тактов до секунды
TSEC:    .BYTE  0    ; секунды
TMIN:    .BYTE  0    ; минуты
THOUR:   .BYTE  0    ; часы
CTIMER:  .WORD  0    ; таймер мерцания курсора
STIMER:  .WORD  0    ; таймер длительности звукового сигнала
KBTIMER: .WORD  0    ; таймер задержки приема данных с клавиатуры
FLTIMER: .WORD  0    ; таймер мерцания символов

; скорости интерфйса
RSPEED:   .ASCII   /  1200/
          .ASCII   /  2400/
          .ASCII   /  4800/
          .ASCII   /  9600/
          .ASCII   / 19200/
          .ASCII   / 38400/
          .ASCII   / 57600/
          .ASCII   /115200/

; Индикаторы служебной строки
RLI$ONL:  .ASCIZ   /LINE /
RLI$LOC:  .ASCIZ   /LOCAL/
RLI$CAP:  .ASCIZ   /CAPS/
RLI$ALT:  .ASCIZ   /ALT/
RLI$KOI:  .ASCIZ   /KOI7/
RLI$RUS:  .ASCIZ   /RUS /
RLI$LAT:  .ASCIZ   /LAT /
RLI$HLD:  .ASCIZ   /HOLD/
RLI$SCR:  .ASCIZ   /WAIT/
RLI$MUT:  .ASCIZ   /MUTE/
RLI$BLK:  .ASCIZ   /     /

          .EVEN


;******************************************************
; Макрос для генерации таблиц описания спецкнопок
;
;    CODE  - сканкод кнопки
;    *SEQ1 - первый байт последовательности
;    *SEQ2 - второй байт последовательности
;    Р - основной режим
;    А - альтернативный режим
;******************************************************
      .MACRO   FKEY   CODE,PSEQ1,PSEQ2,ASEQ1,ASEQ2
      .BYTE       CODE              ; сканкод
      .BYTE       PSEQ1             ; первый байт основной последовательности
      .IF        NB, <PSEQ2>                
      .BYTE       PSEQ2             ; второй основной байт, если есть
      .IFF                        
      .BYTE       0                 ; если нет - 0
      .ENDC 
      .IF        NB, <ASEQ1>
      .BYTE       ASEQ1             ; первый байт альтернативной последовательности
      .IFF
      .BYTE       PSEQ1             ; если его нет, то он совпадает с первым основным байтом
      .ENDC
      .IF        NB, <ASEQ2>                
      .BYTE       ASEQ2             ; второй альтернативный байт если есть
      .IFF                        
      .BYTE       0                 ; если нет - 0
      .ENDC 
      .ENDM    FKEY
      
;***********************************************************************************
;*  Таблица ESC-последовательностей, генерируемых спецкнопками. 
;*                  Сканкоды E0 xx
;***********************************************************************************
EVESC:
      FKEY  112,'Q           ; PF2 - /
      FKEY  165,'A           ; стрелка вверх
      FKEY  162,'B           ; стрелка вниз
      FKEY  164,'C           ; стрелка вправо
      FKEY  153,'D           ; стрелка влево
      FKEY  132,<CR!200>,,77,115   ; kpad enter
      FKEY  154,'H         ; Home - курсор в начало экрана 
      FKEY  160,'P         ; Ins  - раздвижка строки вправо
      FKEY  161,'Q         ; Del  - раздвижка строки влево
      FKEY  172,'S         ; PgDn - раздвижка экрана вниз
      FKEY  175,'T         ; PgUp - раздвижка экрана вверх
      .BYTE 0
      
;***********************************************************************************
;*  Таблица ESC-последовательностей, генерируемых спецкнопками. 
;*                  Сканкоды без E0
;***********************************************************************************
SVESC:
      FKEY  167,'P                 ; PF1 - Numlock
      FKEY  174,'R                 ; PF3 - *
      FKEY  160,<'0!200>,,77,160   ; kpad 0
      FKEY  151,<'1!200>,,77,161   ; kpad 1
      FKEY  162,<'2!200>,,77,162   ; kpad 2
      FKEY  172,<'3!200>,,77,163   ; kpad 3
      FKEY  153,<'4!200>,,77,164   ; kpad 4
      FKEY  163,<'5!200>,,77,165   ; kpad 5
      FKEY  164,<'6!200>,,77,166   ; kpad 6
      FKEY  154,<'7!200>,,77,167   ; kpad 7
      FKEY  165,<'8!200>,,77,170   ; kpad 8
      FKEY  175,<'9!200>,,77,171   ; kpad 9
      FKEY  161,<'.!200>,,77,156   ; kpad .
      FKEY  171,'B                 ; kpad + == down
      FKEY  173,'A                 ; kpad - == up
      .BYTE 0
 
      .EVEN

; Биты состояния клавиатуры для формирования индекса варианта перекодировки
KM.CLR   = 1
KM.SHIFT = 2
KM.CAPS  = 4
KM.KOI   = 10
KM.RUS   = 20
;
;  Таблица выбора варианта перекодировки сканкода в зависимости от режима работы клавиатуры
KSELTAB: 
;
;колонка sctab           RUS    кои-7     caps lk   shift   F$C(L!R) 
;                      KM.RUS  KM.KOI     KM.CAPS KM.SHIFT  KM.CLR          ##d  ##o
; ---- режим LAT --------------------------------------------------------------------- 
.byte   ST.LL       ;    0       0           0       0        0             0     0
.byte   ST.LL       ;    0       0           0       0        1             1     1
.byte   ST.LU       ;    0       0           0       1        0             2     2
.byte   ST.LU       ;    0       0           0       1        1             3     3  
.byte   ST.LL       ;    0       0           1       0        0             4     4
.byte   ST.LU       ;    0       0           1       0        1             5     5
.byte   ST.LU       ;    0       0           1       1        0             6     6
.byte   ST.LL       ;    0       0           1       1        1             7     7
; ---- режим KOI-7-------------------------------------------------------------------- 
.byte   ST.KL       ;    0       1           0       0        0             8     10
.byte   ST.KL       ;    0       1           0       0        1             9     11
.byte   ST.KR       ;    0       1           0       1        0             10    12 
.byte   ST.KR       ;    0       1           0       1        1             11    13
.byte   ST.KL       ;    0       1           1       0        0             12    14
.byte   ST.KR       ;    0       1           1       0        1             13    15 
.byte   ST.KR       ;    0       1           1       1        0             14    16
.byte   ST.KL       ;    0       1           1       1        1             15    17
; ---- режим RUS ---------------------------------------------------------------------
.byte   ST.RU       ;    1       0           0       0        0             16    20
.byte   ST.RU       ;    1       0           0       0        1             17    21
.byte   ST.RL       ;    1       0           0       1        0             18    22
.byte   ST.RL       ;    1       0           0       1        1             19    23
.byte   ST.RU       ;    1       0           1       0        0             20    24 
.byte   ST.RL       ;    1       0           1       0        1             21    25
.byte   ST.RL       ;    1       0           1       1        0             22    26
.byte   ST.RU       ;    1       0           1       1        1             23    27

;************************************************************************************
;* Таблица перекодировки сканкодов 
;************************************************************************************
;
;  --- Варианты состояния клавиатуры:
; LAT-L  - латинские малые буквы
; LAT-U  - латинские большие буквы (с CAPS и shift)
; KOI7-L - русские буквы в режиме koi7
; KOI7-U - латинские буквы в режиме koi7 (с CAPS и shift)
; RUS-L  - малые русские буквы
; RUS-U  - большие русские буквы
; ctrl   - коды, генерируемые при нажатой кнопке CTRL
; flag   - флаги:
F$CL=1 ; - в латинском регистре CAPS влияет на кнопку
F$CR=2 ; - в русском регистре CAPS влияет на кнопку
;
;  Символические имена колонок таблицы. Нумеруются от 0 без учета колонуи кода.
;
ST.LL  = 0    ; Номер колонки LAT-L
ST.LU  = 1    ; Номер колонки LAT-U
ST.KR  = 2    ; Номер колонки KOI-R
ST.KL  = 3    ; Номер колонки KOI-L
ST.RL  = 4    ; Номер колонки RUS-L
ST.RU  = 5    ; Номер колонки RUS-U
ST.CTRL= 6    ; Номер колонки ctrl
ST.FLAG= 7    ; Номер колонки Flag
;*************************************************************************************
SCTAB: ;               0      1         2        3       4      5     6       7             кнопка, соответствующая сканкоду
;             code   Lat-L   LAT-U    KOI7-R   KOI7-L  RUS-L  RUS-U  ctrl    flag   
         .BYTE 15  ,  11 ,  11   ,    11 ,     11  ,   11 ,   11 ,   377   ,   0            ; 0d - tab
         .BYTE 16  ,  '` ,   '~  ,    ', ,     '.  ,   ', ,   '. ,   377   ,   0            ; 0e - ` ~
         .BYTE 21  ,  12 ,   12  ,    12 ,     12  ,   12 ,   12 ,   377   ,   0            ; 11 - l-alt
         .BYTE 25  , 'q  ,   'Q  ,   'j  ,    'Q   ,  'J  ,  'j  ,   21    ,  <F$CL!F$CR>   ; 15 - Q Й
         .BYTE 26  , '1  ,   '!  ,   '!  ,    '1   ,  '!  ,  '1  ,   377   ,   0            ; 16 - 1 !
         .BYTE 32  , 'z  ,   'Z  ,   'q  ,    'Z   ,  'Q  ,  'q  ,   32    ,   <F$CL!F$CR>  ; 1a - Z Я
         .BYTE 33  , 's  ,   'S  ,   'y  ,    'S   ,  'Y  ,  'y  ,   23    ,   <F$CL!F$CR>  ; 1b - S Ы
         .BYTE 34  , 'a  ,   'A  ,   'f  ,    'A   ,  'F  ,  'f  ,   1     ,   <F$CL!F$CR>  ; 1c - A Ф
         .BYTE 35  , 'w  ,   'W  ,   'c  ,    'W   ,  'C  ,  'c  ,   27    ,   <F$CL!F$CR>  ; 1d - W Ц
         .BYTE 36  , '2  ,   '@  ,   '@  ,    '2   ,  042 ,  '2  ,   0     ,   0            ; 1e - 2 @
         .BYTE 41  , 'c  ,   'C  ,   's  ,    'C   ,  'S  ,  's  ,   3     ,   <F$CL!F$CR>  ; 21 - С С
         .BYTE 42  , 'x  ,   'X  ,   '~  ,    'X   ,  '^  ,  '~  ,   30    ,   <F$CL!F$CR>  ; 22 - X Ч
         .BYTE 43  , 'd  ,   'D  ,   'w  ,    'D   ,  'W  ,  'w  ,   4     ,   <F$CL!F$CR>  ; 23 - D В
         .BYTE 44  , 'e  ,   'E  ,   'u  ,    'E   ,  'U  ,  'u  ,   5     ,   <F$CL!F$CR>  ; 24 - E У
         .BYTE 45  , '4  ,   '$  ,   '$  ,    '4   ,  '$  ,  '4  ,   377   ,   0            ; 25 - 4 $
         .BYTE 46  , '3  ,   '#  ,   '#  ,    '3   ,  '#  ,  '3  ,   377   ,   0            ; 26 - 3 #
         .BYTE 51  ,  40 ,  40   ,    40 ,     40  ,   40 ,   40 ,   377   ,   0            ; 29 - space
         .BYTE 52  , 'v  ,   'V  ,   'm  ,    'V   ,  'M  ,  'm  ,   26    ,   <F$CL!F$CR>  ; 2a - V М
         .BYTE 53  , 'f  ,   'F  ,   'a  ,    'F   ,  'A  ,  'a  ,   6     ,   <F$CL!F$CR>  ; 2b - F А
         .BYTE 54  , 't  ,   'T  ,   'e  ,    'T   ,  'E  ,  'e  ,   24    ,   <F$CL!F$CR>  ; 2c - T Е
         .BYTE 55  , 'r  ,   'R  ,   'k  ,    'R   ,  'K  ,  'k  ,   22    ,   <F$CL!F$CR>  ; 2d - R К
         .BYTE 56  , '5  ,   '%  ,   '%  ,    '5   ,  '%  ,  '5  ,   377   ,   0            ; 2e - 5 %
         .BYTE 61  , 'n  ,   'N  ,   't  ,    'N   ,  'T  ,  't  ,   16    ,   <F$CL!F$CR>  ; 31 - N Т
         .BYTE 62  , 'b  ,   'B  ,   'i  ,    'B   ,  'I  ,  'i  ,   2     ,   <F$CL!F$CR>  ; 32 - B И
         .BYTE 63  , 'h  ,   'H  ,   'r  ,    'H   ,  'R  ,  'r  ,   10    ,   <F$CL!F$CR>  ; 33 - H Р
         .BYTE 64  , 'g  ,   'G  ,   'p  ,    'G   ,  'P  ,  'p  ,   7     ,   <F$CL!F$CR>  ; 34 - G П
         .BYTE 65  , 'y  ,   'Y  ,   'n  ,    'Y   ,  'N  ,  'n  ,   31    ,   <F$CL!F$CR>  ; 35 - Y Н 
         .BYTE 66  , '6  ,   '^  ,   '^  ,    '6   ,  '?  ,  '6  ,   36    ,   0            ; 36 - 6 ^
         .BYTE 72  , 'm  ,   'M  ,   'x  ,    'M   ,  'X  ,  'x  ,   15    ,   <F$CL!F$CR>  ; 3a - M Ь
         .BYTE 73  , 'j  ,   'J  ,   'o  ,    'J   ,  'o  ,  'o  ,   12    ,   <F$CL!F$CR>  ; 3b - J О
         .BYTE 74  , 'u  ,   'U  ,   'g  ,    'U   ,  'G  ,  'g  ,   25    ,   <F$CL!F$CR>  ; 3c - U Г
         .BYTE 75  , '7  ,   '&  ,   '&  ,    '7   ,  '&  ,  '7  ,   377   ,   0            ; 3d - 7 &
         .BYTE 76  , '8  ,   '*  ,   '*  ,    '8   ,  '*  ,  '8  ,   377   ,   0            ; 3e - 8 *
         .BYTE 101 , ',  ,   '<  ,   'b  ,    '<   ,  'B  ,  'b  ,   377   ,   F$CR         ; 41 - ,< Б
         .BYTE 102 , 'k  ,   'K  ,   'l  ,    'K   ,  'L  ,  'l  ,   13    ,   <F$CL!F$CR>  ; 42 - K Л
         .BYTE 103 , 'i  ,   'I  ,   '{  ,    'I   ,  '[  ,  '{  ,   11    ,   <F$CL!F$CR>  ; 43 - I Ш
         .BYTE 104 , 'o  ,   'O  ,   '}  ,    'O   ,  ']  ,  '}  ,   17    ,   <F$CL!F$CR>  ; 44 - J О
         .BYTE 105 , '0  ,   ')  ,   ')  ,    '0   ,  ')  ,  '0  ,   377   ,   0            ; 45 - 0
         .BYTE 106 , '9  ,   '(  ,   '(  ,    '9   ,  '(  ,  '9  ,   377   ,   0            ; 46 - 9
         .BYTE 111 , '.  ,   '>  ,   '`  ,    '>   ,  '@  ,  '`  ,   377   ,   F$CR         ; 49 - .> Ю
         .BYTE 112 ,  57 ,  '?   ,   ',  ,    '.   ,  '.  ,  ',  ,   377   ,   0            ; 4a - /,?
         .BYTE 113 , 'l  ,   'L  ,   'd  ,    'L   ,  'D  ,  'd  ,   14    ,   <F$CL!F$CR>  ; 4b - L Д
         .BYTE 114 , ';  ,   ':  ,   'v  ,    ':   ,  'V  ,  'v  ,   377   ,   F$CR         ; 4c - : ; Ж
         .BYTE 115 , 'p  ,   'P  ,   'z  ,    'P   ,  'Z  ,  'z  ,   20    ,   <F$CL!F$CR>  ; 4d - P З
         .BYTE 116 , '-  ,   '_  ,   '-  ,    '_   ,  '_  ,  '-  ,   37    ,   0            ; 4e - - _
         .BYTE 122 , 047 ,   042 ,   174 ,    042  ,  134 ,  174 ,   377   ,   F$CR         ; 52 - "",' Э
         .BYTE 124 , '[  ,   '{  ,   'h  ,    '[   ,  'H  ,  'h  ,   32    ,   F$CR         ; 54 - [ { Х
         .BYTE 125 , '=  ,   '+  ,   '=  ,    '+   ,  '+  ,  '=  ,   377   ,   0            ; 55 - = +
         .BYTE 132 ,  15 ,   15  ,    15 ,     15  ,   15 ,   15 ,   377   ,   0            ; 5a - enter
         .BYTE 133 , ']  ,   '}  ,   ';  ,    ']   ,  ']  ,  ';  ,   35    ,   F$CR         ; 5b - ] } 
         .BYTE 135 , '\  ,   174 ,   '/  ,    '/   ,  '/  ,  '/  ,   34    ,   0            ; 5d - \ | 
         .BYTE 146 ,  177,   177 ,    177,     177 ,   177,   177,   377   ,   0            ; 66 - backspace
         .BYTE 166 ,  33 ,   33  ,    33 ,     33  ,   33 ,   33 ,   377   ,   0            ; 76 - escape
         
         .BYTE  0  ,  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; конец таблицы 
         
      .EVEN                                

;
; Кольцевой буфер выводимых на экран байтов
;
DBUF:    .BLKW  64.
;
; Кольцевой буфер клавиатуры
;
KBDBUF:  .BLKW  8.
    
         .END  0
                          
